
你的音乐播放器里有 N 首不同的歌，在旅途中，你的旅伴想要听 L 首歌（不一定不同，即，允许歌曲重复）。请你为她按如下规则创建一个播放列表：

每首歌至少播放一次。
一首歌只有在其他 K 首歌播放完之后才能再次播放。
返回可以满足要求的播放列表的数量。由于答案可能非常大，请返回它模 10^9 + 7 的结果。

 

示例 1：

输入：N = 3, L = 3, K = 1
输出：6
解释：有 6 种可能的播放列表。[1, 2, 3]，[1, 3, 2]，[2, 1, 3]，[2, 3, 1]，[3, 1, 2]，[3, 2, 1].
示例 2：

输入：N = 2, L = 3, K = 0
输出：6
解释：有 6 种可能的播放列表。[1, 1, 2]，[1, 2, 1]，[2, 1, 1]，[2, 2, 1]，[2, 1, 2]，[1, 2, 2]
示例 3：

输入：N = 2, L = 3, K = 1
输出：2
解释：有 2 种可能的播放列表。[1, 2, 1]，[2, 1, 2]
 

提示：

0 <= K < N <= L <= 100
### DP soltion
思路 1 *****- 时间复杂度: O(NL)*****- 空间复杂度: O(NL)******

DP

dp[i][j]代表用j首不同的歌曲来组成播放列表的前i首歌的可能性，初始化dp[0][0] = 1,其他元素全为0,确定返回dp[L][N]

## 第一种可能性，
第i首歌与前i-1首歌均不重复，先用j-1首不同的歌组成播放列表的前i-1首歌，然后挑选一首与那j-1首歌都不同的歌来作为播放列表的第i首歌

这种情况毫无疑问不需要担心第i首歌与它前面的K首歌出现重复
状态转移方程为dp[i][j] += dp[i-1][j-1] * (N-j+1) % M
## 第二种可能性，

第i首歌与前i-1首歌有重复，先用j首不同的歌组成播放列表的前i-1首歌，然后挑选一首与那j-1首歌重复的歌来作为播放列表的第i首歌

我们需要保证第i首歌与它的前K首歌不出现重复
如果所有不重复的歌都不大于K（即j <= K)，那第i首歌与它前面的K首歌必然出现重复，因此没有这种排列
如果j>K，状态转移方程为dp[i][j] += dp[i-1][j] * (j-K) % M, 我们需要保证第i首歌与它前面的K首歌都不相同，所以第i首歌只能从j-K首歌里面选取
最后返回dp[L][N]，即用N首不同的歌来组成播放列表的前L首歌.
~~~ python
class Solution(object):
    def numMusicPlaylists(self, N, L, K):
        """
        :type N: int
        :type L: int
        :type K: int
        :rtype: int
        """
        M = 10**9+7
        dp = [[0] * (N+1) for i in range(L+1)] # dp[i][j]代表用j首不同的歌曲来组成播放列表的前i首歌的可能性
        dp[0][0] = 1 # 初始化为1种
        for i in range(1, L+1):
            for j in range(1, N+1):
                dp[i][j] += dp[i-1][j-1] * (N-j+1) % M # 第一种可能性
                if j > K:             
                    dp[i][j] += dp[i-1][j] * (j-K) % M # 第二种可能性
        return dp[L][N] % M
~~~
~~~ c++

class Solution {
public:
    int numMusicPlaylists(int N, int L, int K) {
       
        long s[L+1][N+1];
        memset(s,0,sizeof(s));
        s[0][0]=1;
        for(int i=1;i<=L;i++)
        {
            for(int j=1;j<=N;j++)
            { 
                //cout<<s[i-1][j]<<endl;
              s[i][j]+=s[i-1][j-1]*(N-j+1) %(1000000007);
                
                if(j>K)
                    
                    s[i][j]+=s[i-1][j]*(j-K) %1000000007;
                
              // cout<<s[i][j]<<endl;
            }
        }
        return s[L][N]%1000000007;
    }
};
~~~
